using HarmonyLib;
using RimWorld;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;
using UnityEngine.Diagnostics;
using Verse;

namespace Garthor_More_Traits
{
	// Slob trait: generates more filth, doesn't clean.

	public static class GMT_Slob_Helper
	{
		// How much extra filth is generated by slobs
		internal const float slob_factor = 4.0f;
	}

	[HarmonyPatch(typeof(Pawn_FilthTracker), "Notify_EnteredNewCell")]
	public static class Pawn_FilthTracker_Notify_EnteredNewCell_Patch
	{
		static void Postfix(Pawn_FilthTracker __instance)
		{
			// A copy of the normal human-like filth generation, only with a much higher chance to generate filth.
			Pawn pawn = AccessTools.Field(typeof(Pawn_FilthTracker), "pawn").GetValue(__instance) as Pawn;
			if (pawn?.story?.traits?.HasTrait(GMT_DefOf.GMT_Slob) ?? false)
			{
				if (Rand.Value < PawnUtility.HumanFilthChancePerCell(pawn.def, pawn.BodySize) * GMT_Slob_Helper.slob_factor)
				{
					ThingDef filth_Trash;
					ThingDef lastTerrainFilthDef = AccessTools.Field(typeof(Pawn_FilthTracker), "lastTerrainFilthDef").GetValue(__instance) as ThingDef;
					if (lastTerrainFilthDef != null && Rand.Chance(0.66f))
					{
						filth_Trash = lastTerrainFilthDef;
					}
					else
					{
						filth_Trash = ThingDefOf.Filth_Trash;
					}
					if (FilthMaker.TryMakeFilth(pawn.Position, pawn.Map, filth_Trash, 1, (FilthSourceFlags)AccessTools.Method(typeof(Pawn_FilthTracker), "get_AdditionalFilthSourceFlags").Invoke(__instance, null)))
					{
						AccessTools.TypeByName("RimWorld.FilthMonitor").GetMethod("Notify_FilthHumanGenerated").Invoke(null, null);
					}
				}
			}
		}
	}

	// Tried doing this with a transpiler before deciding it was more effort than it's worth, and potentially causes compatibility issues.
	// Keeping work in case I change my mind.
	/*
	/// <summary>
	/// Implements extra filth for the Slob trait by applying a multiplier to the normal chance of dropping trash.
	/// </summary>
	[HarmonyPatch(typeof(Pawn_FilthTracker), "Notify_EnteredNewCell")]
	public static class Pawn_FilthTracker_Notify_EnteredNewCell_Patch
	{
		static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)
		{
			int i = 0;
			List<CodeInstruction> instrs = instructions.ToList();
			
			// Find the location in which we test against filth chance
			for(; i < instrs.Count; ++i)
			{
				if(instrs[i].Is(OpCodes.Call, AccessTools.Method(typeof(PawnUtility),"HumanFilthChancePerCell")))
				{
					yield return instrs[i];
					break;
				}
				yield return instrs[i];
			}

			// Get the presence of the slob trait
			yield return new CodeInstruction(OpCodes.Ldarg_0);
			yield return new CodeInstruction(OpCodes.Ldfld, AccessTools.Field(typeof(Pawn_FilthTracker), "pawn"));
			// Actually this is more effort than it's worth, with all the null checking
			// Multiply by our slobbification factor
			yield return new CodeInstruction(OpCodes.Ldc_I4, 100);
			yield return new CodeInstruction(OpCodes.Mul);
			// Add 1 (for the base filth chance)
			yield return new CodeInstruction(OpCodes.Ldc_I4_1);
			yield return new CodeInstruction(OpCodes.Add);
			// Multiply to get final filth chance value
			yield return new CodeInstruction(OpCodes.Mul);

			// Emit the rest of the method
			for (; i < instrs.Count; ++i)
			{
				yield return instrs[i];
			}
		}
	}
	*/


}
